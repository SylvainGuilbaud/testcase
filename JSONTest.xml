<?xml version="1.0" encoding="UTF-8"?>
<Export generator="IRIS" version="26" zv="IRIS for Windows (x86-64) 2022.1 (Build 209U)" ts="2022-08-25 10:33:37">
<Class name="%JSON.Generator">
<Description><![CDATA[
Generator methods for %JSON.Adaptor.<br><br>

This class is used internally by InterSystems IRIS. You should not make direct
use of it within your applications. There is no guarantee made about either
the behavior or future operation of this class.]]></Description>
<Abstract>1</Abstract>
<IncludeCode>%occInclude,%jsonMap</IncludeCode>
<IncludeGenerator>%occInclude,%jsonMap</IncludeGenerator>
<System>2</System>
<TimeChanged>66338,61479.7767837</TimeChanged>
<TimeCreated>64511,76885.480043</TimeCreated>

<Method name="GenerateMapping">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>class:%String,*mapping</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// Initialize map to empty
	Kill mapping

	// Get the inheritance order
	Do ..LeftSequenceClass(class,.classSeq)

	// Get %JSONIGNOREINVALIDFIELD parameter
	Set jsonignoreinvalidfield=''$$$comMemberKeyGet(class,$$$cCLASSparameter,"%JSONIGNOREINVALIDFIELD",$$$cPARAMdefault)
	
	// Get %JSONMAPPING class parameter.
	Set jsondefaultmapping=$$$comMemberKeyGet(class,$$$cCLASSparameter,"%JSONMAPPING",$$$cPARAMdefault)

	// Get default for %JSONNULL
	Set jsondefaultnull=''$$$comMemberKeyGet(class,$$$cCLASSparameter,"%JSONNULL",$$$cPARAMdefault)

	// Get default for %JSONIGNORENULL
	Set jsondefaultignorenull=''$$$comMemberKeyGet(class,$$$cCLASSparameter,"%JSONIGNORENULL",$$$cPARAMdefault)
 
	// Get default for %JSONREFERENCE
	Set jsondefaultreference=$zcvt($$$comMemberKeyGet(class,$$$cCLASSparameter,"%JSONREFERENCE",$$$cPARAMdefault),"U")
	If jsondefaultreference="" Set jsondefaultreference="OBJECT"
	If $case(jsondefaultreference,"OBJECT":0,"ID":0,"OID":0,"GUID":0,:1) {
		Quit $$$ERROR($$$JSONInvalidDefaultParameter,"parameter %JSONREFERENCE","class base")
	}

	// Create map node for each property
	Set sc=$$$OK
	Set property=""
	For {
		Set property=$$$comMemberNext(class,$$$cCLASSproperty,property)
		If property="" Quit

		// Get %JSONINCLUDE property parameter
		Set jsoninclude=$zcvt($$$comMemberArrayGet(class,$$$cCLASSproperty,property,$$$cPROPparameter,"%JSONINCLUDE"),"L")
		Set includeProperty=$case(jsoninclude,"":"","inout":1,"inputonly":1,"outputonly":1,"none":1,:-1)
		If includeProperty=-1 {
			Set sc=$$$ERROR($$$JSONInvalidPropertyParameter,"parameter %JSONINCLUDE",property,"class base")
			Quit
		}
		
		// Get details of the property's type
		Do ..GetMemberInfo(class,property,.includeProperty,.type,.membercat)
		
		If includeProperty {
			// Default for %JSONINCLUDE is "inout"
			If jsoninclude="" Set jsoninclude="inout"
	
			// Do not support array of streams
			If membercat["STREAM",membercat["Array" {
				Set sc=$$$ERROR($$$JSONNoStreamArray,property,"class base")
				Quit
			}
			
			// For string types, set literaltype to string, base64 or hex.
			Set literaltype=""
			If membercat["CSTREAM" {
				Set literaltype="string"
			} ElseIf membercat["BSTREAM" {
				Set encoding=$$$comMemberArrayGet(class,$$$cCLASSproperty,property,$$$cPROPparameter,"ENCODING")
				Set literaltype=$case($zcvt(encoding,"L"),"":"base64","base64":"base64","hex":"hex",:"")
				If literaltype="" {
					Set sc=$$$ERROR($$$XMLInvalidEncoding,encoding,property)
					Quit
				}
			} ElseIf membercat["LITERAL" {
				Set literaltype=$$$comMemberKeyGet(type,$$$cCLASSparameter,"JSONTYPE",$$$cPARAMdefault)
				If literaltype="" Set literaltype="string"
			
				// We need to differentiate between registered object strings and JSON strings.
				// For example between %String and %Timestamp.
				// A string is considered a registered object string if XSDTYPE, as well as JSONTYPE, is = "string".
				If literaltype="string",$$$comMemberKeyGet(type,$$$cCLASSparameter,"XSDTYPE",$$$cPARAMdefault)'="string" {
					Set literaltype="string/json"
				}
			}
			
			// Find actual class where property is defined.
			Set defClass=$$$comMemberKeyGet(class,$$$cCLASSproperty,property,$$$cPROPorigin)
			
			// Find if required
			Set required=$$$comMemberKeyGet(class,$$$cCLASSproperty,property,$$$cPROPrequired)

			// Get JSON field name. If not specified, then it defaults to the property name.
			Set jsonfieldname=$$$comMemberArrayGet(class,$$$cCLASSproperty,property,$$$cPROPparameter,"%JSONFIELDNAME")
			If jsonfieldname="" Set jsonfieldname=property

			// Get %JSONNULL property parameter.  Default is %JSONNULL class parameter.
			Set jsonnull=$$$comMemberArrayGet(class,$$$cCLASSproperty,property,$$$cPROPparameter,"%JSONNULL")
			Set jsonnull=$select(jsonnull="":jsondefaultnull,1:''jsonnull)

			// Get %JSONIGNORENULL property parameter.  Default is %JSONIGNORENULL class parameter.
			If literaltype="string" {
				Set jsonignorenull=$$$comMemberArrayGet(class,$$$cCLASSproperty,property,$$$cPROPparameter,"%JSONIGNORENULL")
				Set jsonignorenull=$select(jsonignorenull="":jsondefaultignorenull,1:''jsonignorenull)
			} Else {
				Set jsonignorenull=0
			}

			// Get %JSONREFERENCE property parameter.  Default is %JSONREFERENCE class parameter.
			If membercat["OBJ" {
				Set jsonreference=$zcvt($$$comMemberArrayGet(class,$$$cCLASSproperty,property,$$$cPROPparameter,"%JSONREFERENCE"),"U")
				If jsonreference="" Set jsonreference=jsondefaultreference
				Set jsonreference=$case(jsonreference,
										"OBJECT":$$$jsonrefobject,
										"ID":$$$jsonrefid,
										"OID":$$$jsonrefoid,
										"GUID":$$$jsonrefguid,
										:"")
				If jsonreference="" {
					Set sc=$$$ERROR($$$JSONInvalidPropertyParameter,"parameter %JSONREFERENCE",property,"class base")
					Quit
				}

				// Get JSON mapping for object references.
				Set jsonmapping=$$$comMemberArrayGet(class,$$$cCLASSproperty,property,$$$cPROPparameter,"%JSONMAPPING")
				If jsonmapping="" Set jsonmapping=jsondefaultmapping

			} Else {
				Set jsonreference=""
			}

			// Set the node
			Set node=$lb(property,$$$QN(property),jsoninclude,jsonfieldname,jsonnull,jsonignorenull,jsonreference,required,literaltype,membercat,type,jsonmapping)
			Set item=$increment(tempmap)
			Set tempmap(
			    +classSeq-classSeq(defClass)+1,
			    +$$$defMemberKeyGet(defClass,$$$cCLASSproperty,property,$$$cPROPsequencenumber),
			    item)=node
		}
	}
	
	// Copy nodes to map ordered by Sequence Number
	If $$$ISOK(sc) {
		Set mapping($c(1),0)=$lb(class,jsonignoreinvalidfield)

		Set mapping($c(1))=0
		Set cls=""
		For {
			Set cls=$order(tempmap(cls))
			If cls="" Quit
			Set prop=""
			For {
				Set prop=$order(tempmap(cls,prop))
				If prop="" Quit
				Set num=""
				For {
					Set num=$order(tempmap(cls,prop,num))
					If num="" Quit

					Set item=mapping($c(1))+1
					Set mapping($c(1))=item
					Set mapping($c(1),item)=tempmap(cls,prop,num)
				}
			}
		}
	}

	Quit sc
]]></Implementation>
</Method>

<Method name="GetMemberInfo">
<Description><![CDATA[
Return member type information about a property
<pre>
includeProperty is set if passed in as "" which means not specified
member cat is defined by
   <base cat> = "LITERAL" | "OBJPERSISTENT" | "OBJSERIAL" | "OBJREGISTERED" | "CSTREAM" | "BSTREAM"
   If RELATIONSHIP MANY|CHILDREN, then ListCollectionOBJPERSISTENT
   If List Of, then { ArrayCollection | ListCollection } <base cat>
   If %ListOf... or %ArrayOf... { ArrayCollection | ListCollection } <ELEMENTTYPE cat>
   Otherwis <base cat>
type is the type referenced by the property.]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[class:%String,property:%String,&includeProperty:%Boolean,*type:%String,*membercat:%String]]></FormalSpec>
<Implementation><![CDATA[
	Set collection=$$$comMemberKeyGet(class,$$$cCLASSproperty,property,$$$cPROPcollection)
	Set relationship=$$$comMemberKeyGet(class,$$$cCLASSproperty,property,$$$cPROPrelationship)
	Set cardinality=$$$comMemberKeyGet(class,$$$cCLASSproperty,property,$$$cPROPcardinality)

	// Determine default property include if not already specified
	If includeProperty = "" {
		If $$$comMemberKeyGet(class,$$$cCLASSproperty,property,$$$cPROPmultidimensional) {
			Set includeProperty = 0
		} ElseIf $$$comMemberKeyGet(class,$$$cCLASSproperty,property,$$$cPROPprivate)||(property="%Concurrency") {
			Set includeProperty = 0
		} ElseIf relationship,cardinality'="children",cardinality'="many" {
			Set includeProperty = 0
		} Else {
			Set includeProperty = 1
		}
	}
	
	If includeProperty {
		Set type=$$$comMemberKeyGet(class,$$$cCLASSproperty,property,$$$cPROPtype)
		If type="" Set type="%Library.String"
		Set typecat=$$$getClassType(type)

		// Get member category for base type
		Set membercat=##class(%Compiler.XML.Generator.Adaptor).TypeToMembercat(type,typecat,.mixed)
	
		// If no membercat, then do not include property
		If membercat="" Set includeProperty=0
	}
		
	If includeProperty {
		// Modify membercat for collections
		If relationship {
			If (cardinality = "many") || (cardinality = "children") {
				// RELATIONSHIP MANY|CHILDREN = ListCollectionOBJPERSISTENT
				Set membercat = "ListCollection"_membercat
			}
		} Else {
			If collection="" {
				// Not a collection - LITERAL|OBJPERSISTENT|OBJSERIAL|OBJREGISTERED
				If (membercat'="LITERAL") {
					// Get list of super classes
					Kill typeSeq
					Do ##class(%Compiler.XML.Generator.Adaptor).SequenceClass(type,.typeSeq)
					// Check for collection
					If $data(typeSeq("%Library.ArrayOfDataTypes")) {
						Set membercat = "ArrayCollection"
					} ElseIf $data(typeSeq("%Library.ArrayOfObjects")) {
						Set membercat = "ArrayCollection"
					} ElseIf $data(typeSeq("%Library.ListOfDataTypes")) {
						Set membercat = "ListCollection"
					} ElseIf $data(typeSeq("%Library.ListOfObjects")) {
						Set membercat = "ListCollection"
					}
					If membercat["Collection" {
						Set type=$$$comMemberKeyGet(type,$$$cCLASSparameter,"ELEMENTTYPE",$$$cPARAMdefault)
						If membercat'["OBJ",type="" Set type="%Library.String"
						If type="" {
							Set sc=$$$ERROR($$$XMLNeedElementType,property)
							Quit
						}
						Set type=$$$NormalizeClassname(type)
						Set typecat=$$$getClassType(type)
						Set membercat=membercat_##class(%Compiler.XML.Generator.Adaptor).TypeToMembercat(type,typecat,.mixed)
					}
				}
			} Else {
				if collection = $$$cPROPCOLLECTIONLIST {
					// LIST COLLECTION and LITERAL     = ListCollectionLITERAL
					// LIST COLLECTION and otherwise   = ListCollectionOBJ
					Set membercat="ListCollection"_membercat
				} ElseIf collection = $$$cPROPCOLLECTIONARRAY {
					// ARRAY and LITERAL               = ArrayCollectionLITERAL
					// ARRAY and otherwise             = ArrayCollectionOBJ
					Set membercat="ArrayCollection"_membercat
				}
			}
		}
	}
]]></Implementation>
</Method>

<Method name="LeftSequenceClass">
<Description>
Return all super classes in sequence of left to right with super class immediately following its child.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[class:%String,&seqArray]]></FormalSpec>
<Implementation><![CDATA[
	If '$data(seqArray(class)) Set seqArray(class)=$increment(seqArray)
	Set superList=$$$comClassKeyGet(class,$$$cCLASSsuper)
	Set len=$length(superList,",")
	For i=len:-1:1 {
		Set super=$piece(superList,",",i)
		If super'="" {
			Do ..LeftSequenceClass(super,.seqArray)
		}
	}
	Quit
]]></Implementation>
</Method>

<Method name="GenerateMappingFromXdata">
<Description>
Get the JSON adaptor configuration information  from class and property parameters.</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[class:%String,&mapping]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set compiledclass=##class(%Dictionary.CompiledClass).%OpenId(class,,.sc)
	If $$$ISERR(sc) Quit sc

	Set count=compiledclass.XDatas.Count()

	For i=1:1:count {
		Set xdata=compiledclass.XDatas.GetAt(i)
		Set configName=xdata.Name
		If configName="" Continue
		
		#dim reader As %XML.Reader=##class(%XML.Reader).%New()
		Set reader.KeepWhitespace=0
		Set sc=reader.OpenStream(xdata.Data)
		If $$$ISERR(sc) Quit
	
		#dim document As %XML.Document=reader.Document
		#dim node As %XML.Node=document.GetDocumentElement()
	
		If node="" Continue
		If node.LocalName'="Mapping" Continue
		If node.Namespace'="http://www.intersystems.com/jsonmapping" {
			Set sc=$$$ERROR($$$JSONUnexpectedNamespace,node.QName,$$$mappingNameDisplay(configName))
			Quit
		}
		
		Do reader.CorrelateRoot("%JSON.Mapping")
		
		If 'reader.Next(.obj,.sc) Quit
		
		If reader.Next(.dummy) {
			Set sc=$$$ERROR($$$JSONExtraMapping,$$$mappingNameDisplay(configName))
			Quit
		}
		
		Set sc=..GenerateMappingFromClass(class,configName,obj,.mapping)
		If $$$ISERR(sc) Quit
	}

	Quit sc
]]></Implementation>
</Method>

<Method name="GenerateMappingFromClass">
<Description>
Generate mapping based on imported configuration info from Xdata block</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[class:%String,name:%String,obj:%JSON.Mapping,&mapping]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	kill mapping(name)

	// Get %JSONIGNOREINVALIDFIELD parameter
	Set jsonignoreinvalidfield=obj.IgnoreInvalidField
	
	// Get %JSONMAPPING class parameter.
	Set jsondefaultmapping=obj.Mapping

	// Get default for %JSONNULL
	Set jsondefaultnull=''obj.Null

	// Get default for %JSONIGNORENULL
	Set jsondefaultignorenull=''obj.IgnoreNull
 
	// Get default for %JSONREFERENCE
	Set jsondefaultreference=$zcvt(obj.Reference,"U")
	If jsondefaultreference="" Set jsondefaultreference="OBJECT"
	If $case(jsondefaultreference,"OBJECT":0,"ID":0,"OID":0,"GUID":0,:1) {
		Quit $$$ERROR($$$JSONInvalidDefaultParameter,"attribute reference",$$$mappingNameDisplay(name))
	}

	// Save mappng parameterd for entire class
	Set mapping(name,0)=$lb(class,jsonignoreinvalidfield)

	// Create map node for each property
	#dim property As %JSON.MappingProperty
	Set sc=$$$OK
	For i=1:1:obj.propertyList.Count() {
		Set property=obj.propertyList.GetAt(i)
		If property="" {
			Set sc=$$$ERROR($$$JSONNoPropertyName,$$$mappingNameDisplay(name))
			Quit
		}

		Set propertyName=property.Name
		If '$$$comMemberDefined(class,$$$cCLASSproperty,propertyName) {
			Set sc=$$$ERROR($$$JSONUnexpectedPropertyName,propertyName,$$$mappingNameDisplay(name))
			Quit
		}

		// Get %JSONINCLUDE property parameter
		Set jsoninclude=$zcvt(property.Include,"L")
		Set includeProperty=$case(jsoninclude,"":"","inout":1,"inputonly":1,"outputonly":1,"none":1,:-1)
		If includeProperty=-1 {
			Set sc=$$$ERROR($$$JSONInvalidPropertyParameter,"attribute Include",property,$$$mappingNameDisplay(name))
			Quit
		}
		
		// Get details of the property's type
		Do ..GetMemberInfo(class,propertyName,.includeProperty,.type,.membercat)
		
		If includeProperty {
			// Default for %JSONINCLUDE is "inout"
			If jsoninclude="" Set jsoninclude="inout"
	
			// Do not support array of streams
			If membercat["STREAM",membercat["Array" {
				Set sc=$$$ERROR($$$JSONNoStreamArray,property,$$$mappingNameDisplay(name))
				Quit
			}
			
			// For string types, set literaltype to string, base64 or hex.
			Set literaltype=""
			If membercat["CSTREAM" {
				Set literaltype="string"
			} ElseIf membercat["BSTREAM" {
				Set encoding=$$$comMemberArrayGet(class,$$$cCLASSproperty,propertyName,$$$cPROPparameter,"ENCODING")
				Set literaltype=$case($zcvt(encoding,"L"),"":"base64","base64":"base64","hex":"hex",:"")
				If literaltype="" {
					Set sc=$$$ERROR($$$XMLInvalidEncoding,encoding,property)
					Quit
				}
			} ElseIf membercat["LITERAL" {
				Set literaltype=$$$comMemberKeyGet(type,$$$cCLASSparameter,"JSONTYPE",$$$cPARAMdefault)
				If literaltype="" Set literaltype="string"
			
				// We need to differentiate between registered object strings and JSON strings.
				// For example between %String and %Timestamp.
				// A string is considered a registered object string if XSDTYPE, as well as JSONTYPE, is = "string".
				If literaltype="string",$$$comMemberKeyGet(type,$$$cCLASSparameter,"XSDTYPE",$$$cPARAMdefault)'="string" {
					Set literaltype="string/json"
				}
			}
			
			// Find if required
			Set required=$$$comMemberKeyGet(class,$$$cCLASSproperty,propertyName,$$$cPROPrequired)

			// Get JSON field name. If not specified, then it defaults to the property name.
			Set jsonfieldname=property.FieldName
			If jsonfieldname="" Set jsonfieldname=propertyName

			// Get %JSONNULL property parameter.  Default is %JSONNULL class parameter.
			Set jsonnull=property.Null
			Set jsonnull=$select(jsonnull="":jsondefaultnull,1:''jsonnull)

			// Get %JSONIGNORENULL property parameter.  Default is %JSONIGNORENULL class parameter.
			If literaltype="string" {
				Set jsonignorenull=property.IgnoreNull
				Set jsonignorenull=$select(jsonignorenull="":jsondefaultignorenull,1:''jsonignorenull)
			} Else {
				Set jsonignorenull=0
			}

			// Get %JSONREFERENCE property parameter.  Default is %JSONREFERENCE class parameter.
			If membercat["OBJ" {
				Set jsonreference=$zcvt(property.Reference,"U")
				If jsonreference="" Set jsonreference=jsondefaultreference
				Set jsonreference=$case(jsonreference,
										"OBJECT":$$$jsonrefobject,
										"ID":$$$jsonrefid,
										"OID":$$$jsonrefoid,
										"GUID":$$$jsonrefguid,
										:"")
				If jsonreference="" {
					Set sc=$$$ERROR($$$JSONInvalidPropertyParameter,"attribute Reference",property)
					Quit
				}

				// Get JSON mapping for object references.
				Set jsonmapping=property.Mapping
				If jsonmapping="" Set jsonmapping=jsondefaultmapping

			} Else {
				Set jsonreference=""
			}

			// Set the node
			Set mapping(name,$increment(mapping(name)))=
			   $lb(propertyName,$$$QN(propertyName),jsoninclude,jsonfieldname,jsonnull,jsonignorenull,jsonreference,required,literaltype,membercat,type,jsonmapping)
		}
	}

	Quit sc
]]></Implementation>
</Method>

<Method name="%JSONGenerate">
<Description>
%JSONGenerate creates thee metadata structure and generates the code for all methods.</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>%mode,%class,%property,%method,%parameter,%codemode,%code,%classmodify,%context</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set %code=0
	If '$$$comMemberKeyGet(%class,$$$cCLASSparameter,"%JSONENABLED",$$$cPARAMdefault) Quit $$$OK

	Set abstract=$$$comClassKeyGet(%class,$$$cCLASSabstract)
	Set sc=$$$OK

	Set sc=..GenerateMapping(%class,.mapping)
	If $$$ISERR(sc) Quit sc

	Set sc=..GenerateMappingFromXdata(%class,.mapping)
	If $$$ISERR(sc) Quit sc

	// Create the map from class properties
	If 'abstract {
		If $$$ISOK(sc) {
			Set sc=..GenerateAllImportInternal(%class,.mapping)
		}

		If $$$ISOK(sc) {
			Set sc=..GenerateAllExportInternal(%class,.mapping,1)
		}

		If $$$ISOK(sc) {
			Set sc=..GenerateAllExportInternal(%class,.mapping,0)
		}
	}

	Quit sc
]]></Implementation>
</Method>

<Method name="JSONImportInternal">
<Description>
Get the code for the %JSONImportInternal method to actually do the method generation</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>%mode,%class,%property,%method,%parameter,%codemode,%code,%classmodify,%context</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set %code=0
	If $$$comMemberKeyGet(%class,$$$cCLASSparameter,"%JSONENABLED",$$$cPARAMdefault) {
		Merge %code=$$$tEXTcode("%JSONImportInternal")
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="JSONExportInternal">
<Description>
Get the code for the %JSONExportInternal method to actually do the method generation</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>%mode,%class,%property,%method,%parameter,%codemode,%code,%classmodify,%context</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set %code=0
	If $$$comMemberKeyGet(%class,$$$cCLASSparameter,"%JSONENABLED",$$$cPARAMdefault) {
		Merge %code=$$$tEXTcode("%JSONExportInternal")
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="JSONExportToStringInternal">
<Description>
Get the code for the %JSONExportToStringInternal method to actually do the method generation</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>%mode,%class,%property,%method,%parameter,%codemode,%code,%classmodify,%context</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set %code=0
	If $$$comMemberKeyGet(%class,$$$cCLASSparameter,"%JSONENABLED",$$$cPARAMdefault) {
		Merge %code=$$$tEXTcode("%JSONExportToStringInternal")
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="JSONNew">
<ClassMethod>1</ClassMethod>
<FormalSpec>%mode,%class,%property,%method,%parameter,%codemode,%code,%classmodify,%context</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set %code=0
	If $$$comMemberKeyGet(%class,$$$cCLASSparameter,"%JSONENABLED",$$$cPARAMdefault) {
		$$$GENERATE("  Quit ##class("_%class_").%New()")
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="GenerateAllImportInternal">
<Description>
Generate the code for the %JSONImportInternal method</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[class:%String,&mapping:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	New %code
	Set %code=0
	Set sc=$$$OK
	
	Try {
		$$$GENERATE("  Set sc=$$$OK")
		Set needTestInvalidField=0
		Set needRequired=0
		
		// Process all mappings except base
		Set indent=""
		Set mappingName=$c(1)
		Set count=0
		For {
			Set mappingName=$order(mapping(mappingName))
			If mappingName="" Quit
			$$$GENERATE("  "_$select(count=0:"If",1:"} ElseIf")_" %mappingName="""_mappingName_""" {")
			Set count=count+1
			Set indent="  "
			Set sc=..GenerateImportInternal(class,indent,mappingName,.mapping,.needRequired,.needTestInvalidField)
			If $$$ISERR(sc) Quit
		}
		If $$$ISERR(sc) Quit

		// Add in base mapping.
		If count>0 $$$GENERATE("  } Else {")
		Set sc=..GenerateImportInternal(class,indent,$c(1),.mapping,.needRequired,.needTestInvalidField)
		If $$$ISERR(sc) Quit
		If count>0 $$$GENERATE("  }")
		
		// Generate code to check for invalid field
		If needTestInvalidField {
			$$$GENERATE("  If $get(testInvalidField) {")
			$$$GENERATE("    Set invalid=0,iterator=%JSONObject.%GetIterator()")
			$$$GENERATE("    While iterator.%GetNext(.key,.value) { If $data(proplist(key))=0 Set invalid=1 Quit  }")
			$$$GENERATE("    If invalid Quit $$$ERROR($$$JSONImportBadField,key,$$$mappingNameDisplay(%mappingName))")
			$$$GENERATE("  }")
		}

		$$$GENERATE("%JSONImportExit Quit sc")
		$$$GENERATE("%JSONImportError Quit $$$ERROR($$$JSONImportError,field,$$$mappingNameDisplay(%mappingName))")
		If needRequired $$$GENERATE("%JSONImportRequired Quit $$$ERROR($$$JSONImportRequired,field,$$$mappingNameDisplay(%mappingName))")

		// Save the code for this method
		Merge $$$tEXTcode("%JSONImportInternal")=%code

	} Catch ex {
		Set sc=ex.AsStatus()
	}

	Quit sc
]]></Implementation>
</Method>

<Method name="GenerateImportInternal">
<Description>
Generate the code for the %JSONImportInternal method for the specified mappingName.</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[class:%String,indent:%String,mappingName:%String,&mapping:%String,&needRequired:%Boolean,&needTestInvalidField:%Boolean]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc=$$$OK
	Set ignoreInvalidField=$$$jsonignoreinvalidfield(mapping,mappingName)
	If 'ignoreInvalidField {
		Set needTestInvalidField=1
		$$$GENERATE(indent_"  Set testInvalidField=1")
	}

	For index=1:1:$$$jsonpropertycount(mapping,mappingName) {
		Set propertyMap=$$$jsongetprop(mapping,mappingName,index)
		Set fieldname=$replace($$$jsonfieldname(propertyMap),"""","""""")
		
		// Code to indicate property seen
		If 'ignoreInvalidField {
			$$$GENERATE(indent_"  Set proplist("""_fieldname_""")=""""")
		}
		
		// Skip processing for outputonly and none values of JSONINCLUDE.
		If $$$jsoninclude(propertyMap)'["in" Continue
		
		// Code to test if field is present
		$$$GENERATE(indent_"  Set field="""_fieldname_""" Set jsontype=$$$JSONGetTypeOf(%JSONObject,field)")
		$$$GENERATE(indent_"  If jsontype'=""unassigned"" {")
		$$$GENERATE(indent_"    If (jsontype=""string"")&&(%JSONObject.%Get(field,,""stream"")="""") Set jsontype=""null""")
		$$$GENERATE(indent_"    If jsontype=""null"" {")
		// null value does not satisfy field required.
		If $$$jsonrequired(propertyMap) {
			$$$GENERATE(indent_"      Goto %JSONImportRequired")
		} Else {
			$$$GENERATE(indent_"      Set .."_$$$jsonpropertyQN(propertyMap)_"=""""")
		}
		$$$GENERATE(indent_"    } Else {")

		// Generate code to import this property.
		Set membercat=$$$jsonmembercat(propertyMap)
		If membercat["Collection" {
			// Generate code to import collections
			If membercat["List" {
				// Generate code to import lists
				Do ..GenImportList(class,propertyMap,indent_"    ")
			} Else {
				// Generate code to import arrays
				Do ..GenImportArray(class,propertyMap,indent_"    ")
			}
			
		} Else {
			// Generate code to import this non-collection field
			Do ..GenImportField(class,propertyMap,indent_"    ",0)
		}

		// Handle checking for field required.
		If $$$jsonrequired(propertyMap) {
			$$$GENERATE(indent_"  } Else { Goto %JSONImportRequired }")
			Set needRequired=1
		} Else {
			$$$GENERATE(indent_"  }")
		}
	}
		
	Quit sc
]]></Implementation>
</Method>

<Method name="GenImportList">
<Description>
Generate code for importing a JSON array as a List collection.</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>class:%String,propertyMap:%List,indent:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	// If present, then must be the expected JSON array type
	$$$GENERATE(indent_"  If jsontype'=""array"" Goto %JSONImportError")
	$$$GENERATE(indent_"  Set data=%JSONObject."_$$$QN($$$jsonfieldname(propertyMap)))
	// Get each element of the array.
	$$$GENERATE(indent_"  For index=0:1:data.%Size()-1 {")
	// Get the field value
	$$$GENERATE(indent_"    Set jsontype=$$$JSONGetTypeOf(data,index)")
	$$$GENERATE(indent_"    If jsontype=""null"" {")
	$$$GENERATE(indent_"      Do .."_$$$jsonpropertyQN(propertyMap)_".Insert("""")")
	$$$GENERATE(indent_"    } Else {")
	$$$GENERATE(indent_"      Set value=data.%Get(index)")
	// Generate code to import list element
	Do ..GenImportField(class,propertyMap,indent_"    ",$$$isCollectionList)
	$$$GENERATE(indent_"  }}")
]]></Implementation>
</Method>

<Method name="GenImportArray">
<Description>
Generate code for importing an array value from JSON object of the form {"key":value,...}</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>class:%String,propertyMap:%List,indent:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	// If present, then must be the expected JSON object type
	$$$GENERATE(indent_"  If jsontype'=""object"" Goto %JSONImportError")
	$$$GENERATE(indent_"  Set data=%JSONObject."_$$$QN($$$jsonfieldname(propertyMap)))
	$$$GENERATE(indent_"  Set iterator=data.%GetIterator()")
	$$$GENERATE(indent_"  While iterator.%GetNext(.index,.value) {")
	$$$GENERATE(indent_"    Set jsontype=$$$JSONGetTypeOf(data,index)")
	$$$GENERATE(indent_"    If jsontype=""null"" {")
	$$$GENERATE(indent_"      Do .."_$$$jsonpropertyQN(propertyMap)_".SetAt("""",index)")
	$$$GENERATE(indent_"    } Else {")
	Do ..GenImportField(class,propertyMap,indent_"    ",$$$isCollectionArray)
	$$$GENERATE(indent_"  }}")
]]></Implementation>
</Method>

<Method name="GenImportField">
<Description>
Generate code for importing a single field value.</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>class:%String,propertyMap:%List,indent:%String,isCollectionValue:%Integer</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	// Generate code to import this property.
	Set membercat=$$$jsonmembercat(propertyMap)
	If membercat["OBJ" {
		Set reference=$$$jsonreference(propertyMap)
		If reference=$$$jsonrefid {
			// Generate code to import object ID.
			Do ..GenImportID(class,propertyMap,indent,isCollectionValue)
		} ElseIf reference=$$$jsonrefoid {
			// Generate code to import object OID.
			Do ..GenImportOID(class,propertyMap,indent,isCollectionValue)
		} ElseIf reference=$$$jsonrefguid {
			// Generate code to import object GUID.
			Do ..GenImportGUID(class,propertyMap,indent,isCollectionValue)
		} Else {
			// Generate code to import object references.
			Do ..GenImportObject(class,propertyMap,indent,isCollectionValue)
		}

	} ElseIf membercat["STREAM" {
		// Input stream
		If membercat="BSTREAM" {
			// Generate code to import binary stream
			Do ..GenImportBinaryStream(class,propertyMap,indent,isCollectionValue)
		} Else {
			// Generate code to import character stream
			Do ..GenImportCharacterStream(class,propertyMap,indent,isCollectionValue)
		}

	} Else {
		// Generate code to import literals
		Do ..GenImportLiteral(class,propertyMap,indent,isCollectionValue)
	}

	$$$GENERATE(indent_"}")
]]></Implementation>
</Method>

<Method name="GenImportID">
<Description>
Generate code for importing an object ID and storing the object reference in variable named data.</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>class:%String,propertyMap:%List,indent:%String,isCollectionValue:%Integer</FormalSpec>
<Implementation><![CDATA[
	// If present, then must be the expected JSON type
	$$$GENERATE(indent_"  If jsontype'=""string"",jsontype'=""number"" Goto %JSONImportError")
	// Get the field value
	If isCollectionValue {
		Set indexarg=$select(isCollectionValue=$$$isCollectionList:"index+1",1:"index")
		$$$GENERATE(indent_"  Do .."_$$$jsonpropertyQN(propertyMap)_".SetObjectIdAt(value,"_indexarg_")")
	} Else {
		$$$GENERATE(indent_"  Do .."_$$$QN($$$jsonproperty(propertyMap)_"SetObjectId")_"(%JSONObject."_$$$QN($$$jsonfieldname(propertyMap))_")")
	}
]]></Implementation>
</Method>

<Method name="GenImportOID">
<Description>
Generate code for importing an object OID and storing the object reference in variable named data.</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>class:%String,propertyMap:%List,indent:%String,isCollectionValue:%Integer</FormalSpec>
<Implementation><![CDATA[
	// If present, then must be the expected JSON type
	$$$GENERATE(indent_"  If jsontype'=""string"" Goto %JSONImportError")
	// Get the field value
	Set var=$select(isCollectionValue:"value",1:"data")
	Set exp="$lb($piece("_var_","","",2,*),$piece("_var_","","",1))"
	If isCollectionValue {
		Set indexarg=$select(isCollectionValue=$$$isCollectionList:"index+1",1:"index")
		$$$GENERATE(indent_"  Do .."_$$$jsonpropertyQN(propertyMap)_".SetObjectAt("_exp_","_indexarg_")")
	} Else {
		$$$GENERATE(indent_"  Set data=%JSONObject."_$$$QN($$$jsonfieldname(propertyMap)))
		$$$GENERATE(indent_"  Do .."_$$$QN($$$jsonproperty(propertyMap)_"SetObject")_"("_exp_")")
	}
]]></Implementation>
</Method>

<Method name="GenImportGUID">
<Description>
Generate code for importing an object GUID and storing the object reference in variable named data.</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>class:%String,propertyMap:%List,indent:%String,isCollectionValue:%Integer</FormalSpec>
<Implementation><![CDATA[
	// If present, then must be the expected JSON type
	$$$GENERATE(indent_"  If jsontype'=""string"" Goto %JSONImportError")
	// Get the field value
	If isCollectionValue {
		Set indexarg=$select(isCollectionValue=$$$isCollectionList:"index+1",1:"index")
		$$$GENERATE(indent_"  Do .."_$$$jsonpropertyQN(propertyMap)_".SetObjectAt(##class(%Library.GUID).%GUIDFind(value),"_indexarg_")")
	} Else {
		$$$GENERATE(indent_"  Do .."_$$$QN($$$jsonproperty(propertyMap)_"SetObject")_"(##class(%Library.GUID).%GUIDFind(%JSONObject."_$$$QN($$$jsonfieldname(propertyMap))_"))")
	}
]]></Implementation>
</Method>

<Method name="GenImportObject">
<Description>
Generate code for importing a referenced object and storing in variable named data.</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>class:%String,propertyMap:%List,indent:%String,isCollectionValue:%Integer</FormalSpec>
<Implementation><![CDATA[
	Set mappingName=$$$jsonmapping(propertyMap)
	// If present, then must be the expected JSON type
	$$$GENERATE(indent_"  If jsontype=""object"" {")
	// Get a new empty object
	$$$GENERATE(indent_"    Set newobj=##class("_$$$jsontype(propertyMap)_").%JSONNew(%JSONObject,$this)")
	// Get the field value
	$$$GENERATE(indent_"    Set saveJSON=%JSONObject")
	If mappingName'="" {
		$$$GENERATE(indent_"    Set saveMapping=%mappingName,%mappingName="""_mappingName_"""")
	}
	$$$GENERATE(indent_"    Set %JSONObject="_$select(isCollectionValue:"value",1:"%JSONObject."_$$$QN($$$jsonfieldname(propertyMap))))
	// Call adapter for referenced object.
	$$$GENERATE(indent_"    Set sc=newobj.%JSONImportInternal()")
	$$$GENERATE(indent_"    Set %JSONObject=saveJSON")
	If mappingName'="" {
		$$$GENERATE(indent_"    Set %mappingName=saveMapping")
	}
	$$$GENERATE(indent_"    If $$$ISERR(sc) Goto %JSONImportExit")
	If isCollectionValue=$$$isCollectionList {
		// Generate code to save value in list
		$$$GENERATE(indent_"    Do .."_$$$jsonpropertyQN(propertyMap)_".Insert(newobj)")
	} ElseIf isCollectionValue=$$$isCollectionArray {
		// Generate code to save value in array
		$$$GENERATE(indent_"    Do .."_$$$jsonpropertyQN(propertyMap)_".SetAt(newobj,index)")
	} Else {
		// Code to store the property value
		$$$GENERATE(indent_"    Set .."_$$$jsonpropertyQN(propertyMap)_"=newobj")
	}
	$$$GENERATE(indent_"  } ElseIf jsontype=""oref"" {")
	If isCollectionValue=$$$isCollectionList {
		// Generate code to save value in list
		$$$GENERATE(indent_"    Do .."_$$$jsonpropertyQN(propertyMap)_".Insert(value)")
	} ElseIf isCollectionValue=$$$isCollectionArray {
		// Generate code to save value in array
		$$$GENERATE(indent_"    Do .."_$$$jsonpropertyQN(propertyMap)_".SetAt(value,index)")
	} Else {
		// Code to store the property value
		$$$GENERATE(indent_"    Set .."_$$$jsonpropertyQN(propertyMap)_"=%JSONObject."_$$$QN($$$jsonfieldname(propertyMap)))
	}
	$$$GENERATE(indent_"  } Else { Goto %JSONImportError }")
]]></Implementation>
</Method>

<Method name="GenImportBinaryStream">
<Description>
Generate code for getting the field value from a binary stream and storing in variable named data.</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>class:%String,propertyMap:%List,indent:%String,isCollectionValue:%Integer</FormalSpec>
<Implementation><![CDATA[
	Set property=$$$jsonproperty(propertyMap)
	
	// If present, then must be the expected JSON type
	$$$GENERATE(indent_"  If jsontype'=""string"" Goto %JSONImportError")
	// Get the field value
	If isCollectionValue {
		// Code for new stream to insert
		Set indexarg=$select(isCollectionValue=$$$isCollectionList:"index+1",1:"index")
		$$$GENERATE(indent_"  Set stream=..##class("_$$$jsontype(propertyMap)_").%New()")
		If $$$jsonliteraltype(propertyMap)["hex" {
			$$$GENERATE(indent_"  For i=1:16:$length(value)-15 { Set bin=bin_$re($zqc($zhex($e(value,i,i+15)))) }")
			$$$GENERATE(indent_"  For i=i+16:2:$length(value)-1 { Set bin=bin_$char($zhex($extract(value,i,i+1))) }")
			$$$GENERATE(indent_"  Set sc=stream.Write(value) If $$$ISERR(sc) Goto %JSONImportExit")
		} Else {
			$$$GENERATE(indent_"  Set sc=stream.Write($system.Encryption.Base64Decode(value)) If $$$ISERR(sc) Goto %JSONImportExit")
		}
		If isCollectionValue=$$$isCollectionList {
			// Generate code to save value in list
			$$$GENERATE(indent_"  Do .."_$$$jsonpropertyQN(propertyMap)_".Insert(stream)")
		} Else {
			// Generate code to save value in array
			$$$GENERATE(indent_"  Do .."_$$$jsonpropertyQN(propertyMap)_".SetAt(stream,index)")
		}
	} Else {
		// Code to use property stream
		$$$GENERATE(indent_"  Set tStream = %JSONObject.%Get("""_$$$jsonfieldname(propertyMap)_""",,""stream"")")
		$$$GENERATE(indent_"  Set stream=.."_$$$jsonpropertyQN(propertyMap)_" Do stream.Rewind()")
		$$$GENERATE(indent_"  If tStream.Size>0 { While 'tStream.AtEnd {")
		If $$$jsonliteraltype(propertyMap)["hex" {
			$$$GENERATE(indent_"  Set value=tStream.Read(32000),bin=""""")
			$$$GENERATE(indent_"  For i=1:16:$length(value)-15 { Set bin=bin_$re($zqc($zhex($e(value,i,i+15)))) }")
			$$$GENERATE(indent_"  For i=i+16:2:$length(value)-1 { Set bin=bin_$char($zhex($extract(value,i,i+1))) }")
			$$$GENERATE(indent_"  Set sc=stream.Write(bin) If $$$ISERR(sc) Goto %JSONImportExit")
		} Else {
			$$$GENERATE(indent_"    Set rc=stream.Write($system.Encryption.Base64Decode(tStream.Read(43540,.sc))) Set:$$$ISERR(rc) sc=$$$ADDSC(sc,rc) If $$$ISERR(sc) Goto %JSONImportExit")
		}
		$$$GENERATE(indent_"  }}")
		$$$GENERATE(indent_"  Set %JSONObject."_$$$QN($$$jsonfieldname(propertyMap))_" = """"")
		$$$GENERATE(indent_"  Do %JSONObject.%Remove("""_$$$jsonfieldname(propertyMap)_""")")
	}
]]></Implementation>
</Method>

<Method name="GenImportCharacterStream">
<Description>
Generate code for getting the field value from a character stream and storing in variable named data.</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>class:%String,propertyMap:%List,indent:%String,isCollectionValue:%Integer</FormalSpec>
<Implementation><![CDATA[
	Set property=$$$jsonproperty(propertyMap)
	
	// If present, then must be the expected JSON type
	$$$GENERATE(indent_"  If jsontype'=""string"" Goto %JSONImportError")
	// Get the field value
	If isCollectionValue {
		// Code for new stream to insert
		Set indexarg=$select(isCollectionValue=$$$isCollectionList:"index+1",1:"index")
		$$$GENERATE(indent_"  Set stream=..##class("_$$$jsontype(propertyMap)_").%New()")
		$$$GENERATE(indent_"  Set sc=stream.Write(value) If $$$ISERR(sc) Goto %JSONImportExit")
		If isCollectionValue=$$$isCollectionList {
			// Generate code to save value in list
			$$$GENERATE(indent_"  Do .."_$$$jsonpropertyQN(propertyMap)_".Insert(stream)")
		} Else {
			// Generate code to save value in array
			$$$GENERATE(indent_"  Do .."_$$$jsonpropertyQN(propertyMap)_".SetAt(stream,index)")
		}
	} Else {
		// Code to use property stream
    $$$GENERATE(indent_"  Set tStream = %JSONObject.%Get("""_$$$jsonfieldname(propertyMap)_""",,""stream"")")
		$$$GENERATE(indent_"  Set stream=.."_$$$jsonpropertyQN(propertyMap)_" Do stream.Rewind()")
    $$$GENERATE(indent_"  If tStream.Size>0 { ")
		$$$GENERATE(indent_"    Set sc=stream.CopyFrom(tStream) If $$$ISERR(sc) Goto %JSONImportExit")
    $$$GENERATE(indent_"  }")
    $$$GENERATE(indent_"  Set %JSONObject."_$$$QN($$$jsonfieldname(propertyMap))_" = """"")
    $$$GENERATE(indent_"  Do %JSONObject.%Remove("""_$$$jsonfieldname(propertyMap)_""")")
	}
]]></Implementation>
</Method>

<Method name="GenImportLiteral">
<Description>
Generate code for getting the field value and storing in variable named data.</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>class:%String,propertyMap:%List,indent:%String,isCollectionValue:%Integer</FormalSpec>
<Implementation><![CDATA[
	Set property=$$$jsonproperty(propertyMap)
	Set type=$$$jsontype(propertyMap)
	Set literaltype=$$$jsonliteraltype(propertyMap)
	
	// If present, then must be the expected JSON type
	If literaltype="double" {
		$$$GENERATE(indent_"  If jsontype'=""number"",jsontype'=""string"" Goto %JSONImportError")
	} Else {
		$$$GENERATE(indent_"  If jsontype'="""_$piece(literaltype,"/",1)_""" Goto %JSONImportError")
	}
	// Get the field value
	If isCollectionValue {
		Set var="value"
	} Else {
		Set var="data"
	}
	
	Set useProperty='isCollectionValue
	If literaltype'="boolean" { // boolean JSON values need nop additional processing.
		// Get information about data type class
		Do ##class(%Compiler.XML.Generator.Adaptor).getPropertyParameters(class,property,.parms)
		Set haveJSONToLogical=##class(%Compiler.XML.Generator.Adaptor).getSingleLine(class,property,type,"JSONToLogical",.parms,var,.codeJSONToLogical)
		// Try to use XSDToLogical if JSONToLogical is not specified.  
		// The point is to avoid extra property mnethods being geenrated.
		If 'haveJSONToLogical {
			Set haveJSONToLogical=##class(%Compiler.XML.Generator.Adaptor).getSingleLine(class,property,type,"XSDToLogical",.parms,var,.codeJSONToLogical)
		}
		Set haveIsValid=##class(%Compiler.XML.Generator.Adaptor).getSingleLine(class,property,type,"IsValid",.parms,var,.codeIsValid)
		
		// Call datatype methods
		Set line=""
		If haveJSONToLogical {
			Set line=line_" Set "_var_"="_codeJSONToLogical_" Goto:"_var_"="""" %JSONImportError"
		}
		If haveIsValid {
			Set line=line_" If $$$ISERR("_codeIsValid_") Goto %JSONImportError"
		}
		If line'="" {
			If useProperty {
				Set useProperty=0
				$$$GENERATE(indent_"  Set data=%JSONObject."_$$$QN($$$jsonfieldname(propertyMap)))
			}
			$$$GENERATE(indent_" "_line)
		}
		// Handle the ignorenull case
		If literaltype="string",'$$$jsonignorenull(propertyMap) {
			If useProperty {
				Set useProperty=0
				$$$GENERATE(indent_"  Set data=%JSONObject."_$$$QN($$$jsonfieldname(propertyMap)))
			}
			$$$GENERATE(indent_"  If "_var_"="""" Set "_var_"=$c(0)")
		}
	}
	If isCollectionValue=$$$isCollectionList {
		// Generate code to save value in list
		$$$GENERATE(indent_"  Do .."_$$$jsonpropertyQN(propertyMap)_".Insert("_var_")")
	} ElseIf isCollectionValue=$$$isCollectionArray {
		// Generate code to save value in array
		$$$GENERATE(indent_"  Do .."_$$$jsonpropertyQN(propertyMap)_".SetAt("_var_",index)")
	} Else {
		// Code to store the property value
		If useProperty Set var="%JSONObject."_$$$QN($$$jsonfieldname(propertyMap))
		$$$GENERATE(indent_"  Set .."_$$$jsonpropertyQN(propertyMap)_"="_var)
	}
]]></Implementation>
</Method>

<Method name="GenerateAllExportInternal">
<Description>
Generate the code for the %JSONExportInternal method</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[class:%String,&mapping:%String,useWrite:%Boolean]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	New %code,%outputCode,%exitCode,%objectCode
	Set %code=0
	Set sc=$$$OK
	
	Try {
		// Setup the output code for write or string concatenation.
		If useWrite {
			Set %outputCode="Write "
			Set %exitCode="%JSONExportExit"
			Set %objectCode="%JSONExportInternal"
		} Else {
			Set %outputCode="Set %export=%export_"
			Set %exitCode="%JSONExportExitToString"
			Set %objectCode="%JSONExportToStringInternal"
		}
		
		// Begin output of code
		$$$GENERATE("  Set sc=$$$OK")
		$$$GENERATE("  "_%outputCode_"""{"" Set sep=""""")
		
		// Process all mappings except base
		Set indent=""
		Set mappingName=$c(1)
		Set count=0
		For {
			Set mappingName=$order(mapping(mappingName))
			If mappingName="" Quit
			$$$GENERATE("  "_$select(count=0:"If",1:"} ElseIf")_" %mappingName="""_mappingName_""" {")
			Set count=count+1
			Set indent="  "
			Set sc=..GenerateExportInternal(class,indent,mappingName,.mapping)
			If $$$ISERR(sc) Quit
		}
		If $$$ISERR(sc) Quit

		// Add in base mapping.
		If count>0 $$$GENERATE("  } Else {")
		Set sc=..GenerateExportInternal(class,indent,$c(1),.mapping)
		If $$$ISERR(sc) Quit
		If count>0 $$$GENERATE("  }")
		
    	$$$GENERATE("  "_%outputCode_"""}""")
		$$$GENERATE(%exitCode_" Quit sc")

		// Save the code for this method
		Merge $$$tEXTcode("%JSONExport"_$select(useWrite:"",1:"ToString")_"Internal")=%code

	} Catch ex {
		Set sc=ex.AsStatus()
	}

	Quit sc
]]></Implementation>
</Method>

<Method name="GenerateExportInternal">
<Description>
Generate the code for the specified mapping of %JSONExportInternal method</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[class:%String,indent:%String,mappingName:%String,&mapping:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc=$$$OK
	
	// Loop over all properties
	For index=1:1:$$$jsonpropertycount(mapping,mappingName) {
		Set propertyMap=$$$jsongetprop(mapping,mappingName,index)
		Set fieldname=$$$jsonfieldname(propertyMap)
		
		// Skip procssing for inputonly and none values of JSONINCLUDE.
		If $$$jsoninclude(propertyMap)'["out" Continue
		
		// Generate code to import this property.
		Set membercat=$$$jsonmembercat(propertyMap)
		If membercat["Collection" {
			// Generate code to import collections
			$$$GENERATE("    Set aval=.."_$$$jsonpropertyQN(propertyMap))
			If membercat["List" {
				// Generate code to import lists
				Do ..GenExportList(class,propertyMap,indent)
			} Else {
				// Generate code to import arrays
				Do ..GenExportArray(class,propertyMap,indent)
			}
			
		} Else {
			// Generate code to import this non-collection field
			$$$GENERATE(indent_"  Set value=.."_$$$jsonpropertyQN(propertyMap))
			Do ..GenExportField(class,propertyMap,fieldname,indent,0)
		}
	}
		
	Quit sc
]]></Implementation>
</Method>

<Method name="GenExportList">
<Description>
Generate code for exporting a List collection as a JSON array.</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>class:%String,propertyMap:%List,indent:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	Set jsonreference=$$$jsonreference(propertyMap) 
	If jsonreference=$$$jsonrefoid {
		Set nextFunction="GetObjectNext"
	} ElseIf jsonreference=$$$jsonrefguid {
		Set nextFunction="GetNext"
	} ElseIf jsonreference=$$$jsonrefid {
		Set nextFunction="GetObjectIdNext"
	} Else {
		Set nextFunction="GetNext"
	}
	$$$GENERATE(indent_"  If aval.Count()>0 {")
	Do ..GenWriteField($$$jsonfieldname(propertyMap),indent_"  ","")
	$$$GENERATE(indent_"    Set sep=""[""")
	$$$GENERATE(indent_"    Set k="""" For {")
	$$$GENERATE(indent_"      Set value=aval."_nextFunction_"(.k) If k="""" Quit")
	Do ..GenExportField(class,propertyMap,"","      ",$$$isCollectionList)
	$$$GENERATE(indent_"    }")
   	$$$GENERATE(indent_"    "_%outputCode_"""]""")
   	$$$GENERATE(indent_"  }")
]]></Implementation>
</Method>

<Method name="GenExportArray">
<Description>
Generate code for exporting an array collection value from JSON object of the form {"key":value,...}</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>class:%String,propertyMap:%List,indent:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	Set jsonreference=$$$jsonreference(propertyMap)
	If jsonreference=$$$jsonrefoid {
		Set nextFunction="GetObjectNext"
	} ElseIf jsonreference=$$$jsonrefguid {
		Set nextFunction="GetNext"
	} ElseIf jsonreference=$$$jsonrefid {
		Set nextFunction="GetObjectIdNext"
	} Else {
		Set nextFunction="GetNext"
	}
	$$$GENERATE(indent_"  If aval.Count()>0 {")
	Do ..GenWriteField($$$jsonfieldname(propertyMap),indent_"  ","")
	$$$GENERATE(indent_"    Set sep=""{""")
	$$$GENERATE(indent_"    Set aval=.."_$$$jsonpropertyQN(propertyMap)_",k=""""")
	$$$GENERATE(indent_"    For {")
	$$$GENERATE(indent_"      Set value=aval."_nextFunction_"(.k) If k="""" Quit")
	Do ..GenExportField(class,propertyMap,$c(1)_"k",indent_"    ",$$$isCollectionArray)
	$$$GENERATE(indent_"    }")
   	$$$GENERATE(indent_"    "_%outputCode_"""}""")
   	$$$GENERATE(indent_"  }")
]]></Implementation>
</Method>

<Method name="GenExportField">
<Description>
Generate code for exporting a single field value.</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>class:%String,propertyMap:%List,fieldName:%String,indent:%String,isCollectionValue:%Integer</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	Set needClosingBrace=1
	// Generate code to import this property.
	Set membercat=$$$jsonmembercat(propertyMap)
	If membercat["OBJ" {
		// Handle no object specified.
		Set serialTest=$select(membercat["SERIAL":"&&'value.%IsNull()",1:"")
		$$$GENERATE(indent_"  If value'="""""_serialTest_" {")
		Set indent=indent_"  "
		// Output JSON for the object reference
		Set reference=$$$jsonreference(propertyMap)
		If reference=$$$jsonrefid {
			// Generate code to export object ID.
			Do ..GenExportID(class,propertyMap,fieldName,indent,isCollectionValue)
		} ElseIf reference=$$$jsonrefoid {
			// Generate code to export object OID.
			Do ..GenExportOID(class,propertyMap,fieldName,indent,isCollectionValue)
		} ElseIf reference=$$$jsonrefguid {
			// Generate code to export object GUID.
			Do ..GenExportGUID(class,propertyMap,fieldName,indent,isCollectionValue)
		} Else {
			// Generate code to export object references.
			Do ..GenExportObject(class,propertyMap,fieldName,indent,isCollectionValue)
		}

	} ElseIf membercat["STREAM" {
		// Handle no stream specified.
		If $$$jsonliteraltype(propertyMap)="string",$$$jsonignorenull(propertyMap) {
			Set needClosingBrace=0
		} Else {
			$$$GENERATE(indent_"  If (value'="""")&&'value.IsNull() {")
			Set indent=indent_"  "
		}
		// Output stream
		If membercat="BSTREAM" {
			// Generate code to export binary stream
			Do ..GenExportBinaryStream(class,propertyMap,fieldName,indent,isCollectionValue)
		} Else {
			// Generate code to export character stream
			Do ..GenExportCharacterStream(class,propertyMap,fieldName,indent,isCollectionValue)
		}

	} Else {
		// Handle no value specified.
		If $$$jsonliteraltype(propertyMap)="string",$$$jsonignorenull(propertyMap) {
			Set needClosingBrace=0
		} Else {
			$$$GENERATE(indent_"  If value'="""" {")
			Set indent=indent_"  "
		}
		// Generate code to export literals
		Do ..GenExportLiteral(class,propertyMap,fieldName,indent,isCollectionValue)
	}
	
   	If needClosingBrace {
		If isCollectionValue || ($$$jsonnull(propertyMap) && '$$$jsonignorenull(propertyMap)) {
			$$$GENERATE(indent_"} Else {")
			Do ..GenWriteField(fieldName,indent,"""null""")
	   		$$$GENERATE(indent_"}")
		   	$$$GENERATE(indent_"Set $extract(sep,1)="",""")
		} Else {
		   	$$$GENERATE(indent_"  Set $extract(sep,1)="",""")
	   		$$$GENERATE(indent_"}")
		}
	} Else {
	   	$$$GENERATE(indent_"  Set $extract(sep,1)="",""")
	}
]]></Implementation>
</Method>

<Method name="GenExportID">
<Description>
Generate code for exporting an object ID as JSON.</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>class:%String,propertyMap:%List,fieldName:%String,indent:%String,isCollectionValue:%Integer</FormalSpec>
<Implementation><![CDATA[
	// Write the field value
	If isCollectionValue {
		// GetObjectNextId already returned id
		Do ..GenWriteField(fieldName,indent,"""""""""_$zcvt(value,""O"",""JSON"")_""""""""")
	} Else {
		Do ..GenWriteField(fieldName,indent,"""""""""_$zcvt(value.%Id(),""O"",""JSON"")_""""""""")
	}
]]></Implementation>
</Method>

<Method name="GenExportOID">
<Description>
Generate code for exporting an object OID as JSON.</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>class:%String,propertyMap:%List,fieldName:%String,indent:%String,isCollectionValue:%Integer</FormalSpec>
<Implementation><![CDATA[
	// Write the field value
	If isCollectionValue {
		// GetObjectNextId already returned oid
		Do ..GenWriteField(fieldName,indent,"""""""""_$select($listget(value,2)="""":$listget(aval.GetAt(k).%Oid(),2),1:$listget(value,2))_"",""_$listget(value)_""""""""")
	} Else {
		Do ..GenWriteField(fieldName,indent,"""""""""_$listget(value.%Oid(),2)_"",""_$listget(value.%Oid())_""""""""")
	}
]]></Implementation>
</Method>

<Method name="GenExportGUID">
<Description>
Generate code for exporting an object GUID as JSON.</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>class:%String,propertyMap:%List,fieldName:%String,indent:%String,isCollectionValue:%Integer</FormalSpec>
<Implementation><![CDATA[	Do ..GenWriteField(fieldName,indent,"""""""""_value.%GUID(value.%Oid())_""""""""")
]]></Implementation>
</Method>

<Method name="GenExportObject">
<Description>
Generate code for exporting a referenced object as JSON.</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>class:%String,propertyMap:%List,fieldName:%String,indent:%String,isCollectionValue:%Integer</FormalSpec>
<Implementation><![CDATA[
	Set mappingName=$$$jsonmapping(propertyMap)
	If mappingName'="" {
		$$$GENERATE(indent_"  Set saveMapping=%mappingName,%mappingName="""_mappingName_"""")
	}
	// Write the field value
	Do ..GenWriteField(fieldName,indent,"")
	$$$GENERATE(indent_"  Set sc=value."_%objectCode_"() If $$$ISERR(sc) Goto "_%exitCode)
	If mappingName'="" {
		$$$GENERATE(indent_"  Set %mappingName=saveMapping")
	}
]]></Implementation>
</Method>

<Method name="GenExportBinaryStream">
<Description>
Generate code for exporting a binary stream as JSON.</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>class:%String,propertyMap:%List,fieldName:%String,indent:%String,isCollectionValue:%Integer</FormalSpec>
<Implementation><![CDATA[
	Do ..GenWriteField(fieldName,indent,"")
	If $$$jsonliteraltype(propertyMap)["hex" {
		$$$GENERATE(indent_"  "_%outputCode_""""""""" Do value.Rewind() If value.Size>0 { While 'value.AtEnd { ")
		$$$GENERATE(indent_"    Set first=value.Read(.len,.sc) If $$$ISERR(sc) Goto "_%exitCode)
    	$$$GENERATE(indent_"    For k=1:8:$length(first)-7 {"_%outputCode_"$tr($j($zhex($zqa($re($e(first,k,k+7)))),16),"" "",""0"") }")
    	$$$GENERATE(indent_"    For k=k+8:1:$length(first) {"_%outputCode_"$select($ascii(first,k)<16:""0"",1:"""")_$zhex($ascii(first,k)) }")
		$$$GENERATE(indent_"  }} "_%outputCode_"""""""""")
	} Else {
		$$$GENERATE(indent_"  "_%outputCode_""""""""" Do value.Rewind() If value.Size>0 { While 'value.AtEnd { "_%outputCode_"$system.Encryption.Base64Encode(value.Read(32655,.sc),1) If $$$ISERR(sc) Goto "_%exitCode_" }} "_%outputCode_"""""""""")
	}
]]></Implementation>
</Method>

<Method name="GenExportCharacterStream">
<Description>
Generate code for exporting a character stream as JSON.</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>class:%String,propertyMap:%List,fieldName:%String,indent:%String,isCollectionValue:%Integer</FormalSpec>
<Implementation><![CDATA[
	Do ..GenWriteField(fieldName,indent,"")
	$$$GENERATE(indent_"  "_%outputCode_""""""""" Do value.Rewind() If value.Size>0 { While 'value.AtEnd { "_%outputCode_"$zcvt(value.Read(,.sc),""O"",""JSON"") If $$$ISERR(sc) Goto "_%exitCode_" }} "_%outputCode_"""""""""")
]]></Implementation>
</Method>

<Method name="GenExportLiteral">
<Description>
Generate code for exporting a literal value as JSON.</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>class:%String,propertyMap:%List,fieldName:%String,indent:%String,isCollectionValue:%Integer</FormalSpec>
<Implementation><![CDATA[
	Set property=$$$jsonproperty(propertyMap)
	Set type=$$$jsontype(propertyMap)
	
	// Get information about data type class
	Do ##class(%Compiler.XML.Generator.Adaptor).getPropertyParameters(class,property,.parms)
	Set haveLogicalToJSON=##class(%Compiler.XML.Generator.Adaptor).getSingleLine(class,property,type,"LogicalToJSON",.parms,"value",.codeLogicalToJSON)
	// Try to use LogicalToXSD if LogicalToJSON is not specified.  
	// The point is to avoid extra property mnethods being geenrated.
	If 'haveLogicalToJSON {
		Set haveLogicalToJSON=##class(%Compiler.XML.Generator.Adaptor).getSingleLine(class,property,type,"LogicalToXSD",.parms,"value",.codeLogicalToJSON)
	}
	If 'haveLogicalToJSON Set codeLogicalToJSON="value"
	Set literaltype=$$$jsonliteraltype(propertyMap)
	If $piece(literaltype,"/",1)="string" {
		If literaltype="string" {
			Set codeLogicalToJSON="$select("_$select($$$jsonignorenull(propertyMap):"(value="""""""")||",1:"")_"(value=$c(0)):"""",1:$zcvt("_codeLogicalToJSON_",""O"",""JSON""))"
		}
		Set codeLogicalToJSON="""""""""_"_codeLogicalToJSON_"_"""""""""
	} ElseIf literaltype="boolean" {
		Set codeLogicalToJSON="$select(value:""true"",1:""false"")"
	}
	Do ..GenWriteField(fieldName,indent,codeLogicalToJSON)
]]></Implementation>
</Method>

<Method name="GenWriteField">
<Description>
Generate code to write out the field name and value</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>fieldName:%String,indent:%String,valueText:%String</FormalSpec>
<Implementation><![CDATA[
	If fieldName'="" {
		// If first character of fieldName is $c(1), then the name is actually a variable name that contains field name
		If $extract(fieldName,1)=$c(1) {
			Set field="""_"_$replace($zcvt($extract(fieldName,2,*),"O","JSON"),"""","""""")_"_"""
		} Else {
			set field=$replace($zcvt(fieldName,"O","JSON"),"""","""""")
		}
		If valueText'="" {
			$$$GENERATE(indent_"  "_%outputCode_"sep_"_""""""""_field_""""""_$select($extract(valueText,1)="""":":"_$extract(valueText,2,*),1:":""_"_valueText))
		} Else {
			$$$GENERATE(indent_"  "_%outputCode_"sep_"_""""""""_field_""""":""")
		}
	} Else {
		$$$GENERATE(indent_"  "_%outputCode_"sep"_$select(valueText="":"",1:"_")_valueText)
	}
]]></Implementation>
</Method>
</Class>


<Class name="data.test">
<ClassType>persistent</ClassType>
<Super>%Persistent,%XML.Adaptor,%JSON.Adaptor,%Populate</Super>
<TimeChanged>66332,68581.2265148</TimeChanged>
<TimeCreated>66332,68581.2265148</TimeCreated>

<Property name="String">
<Type>%String</Type>
<Parameter name="MAXLEN"/>
<Parameter name="POPSPEC" value="Mission()"/>
</Property>

<Property name="BStream">
<Type>%Stream.GlobalBinary</Type>
<Parameter name="POPSPEC" value="##class(data.test).BStreamPop()"/>
</Property>

<Property name="CStream">
<Type>%Stream.GlobalCharacter</Type>
<Parameter name="POPSPEC" value="##class(data.test).CStreamPop()"/>
</Property>

<Property name="Numeric">
<Type>%Numeric</Type>
</Property>

<Property name="Integer">
<Type>%Integer</Type>
</Property>

<Property name="Float">
<Type>%Float</Type>
</Property>

<Property name="Double">
<Type>%Double</Type>
</Property>

<Property name="Date">
<Type>%Date</Type>
</Property>

<Property name="Timestamp">
<Type>%TimeStamp</Type>
</Property>

<Property name="Boolean">
<Type>%Boolean</Type>
</Property>

<Property name="extension">
<Type>%String</Type>
<InitialExpression>"pdf"</InitialExpression>
</Property>

<Property name="created">
<Type>%TimeStamp</Type>
<InitialExpression>$zdt($now(),3,,6)</InitialExpression>
</Property>

<Index name="StringIndex">
<Properties>String</Properties>
</Index>

<Index name="BStreamIndex">
<Properties>BStream</Properties>
</Index>

<Index name="CStreamIndex">
<Properties>CStream</Properties>
</Index>

<Index name="NumericIndex">
<Properties>Numeric</Properties>
</Index>

<Index name="IntegerIndex">
<Properties>Integer</Properties>
</Index>

<Index name="FloatIndex">
<Properties>Float</Properties>
</Index>

<Index name="DoubleIndex">
<Properties>Double</Properties>
</Index>

<Index name="DateIndex">
<Properties>Date</Properties>
</Index>

<Index name="TimestampIndex">
<Properties>Timestamp</Properties>
</Index>

<Index name="BooleanIndex">
<Properties>Boolean</Properties>
</Index>

<Method name="add">
<ClassMethod>1</ClassMethod>
<FormalSpec>filename:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    set sc=$$$OK
    Try {
        // default value if filename parameter is null
        set:filename="" filename = $system.Util.DataDirectory()_"docs/copyright.pdf"
        if ##class(%File).Exists(filename) {
            set a = ..%New()
            set a.String = $PIECE(filename,"/",*)
            set a.extension = $PIECE(a.String,".",*)
            set file=##class(%Stream.FileBinary).%New()
            set sc=file.LinkToFile(filename)
            do a.BStream.CopyFrom(file)
            do a.CStream.CopyFrom(file)
            set a.Numeric = a.BStream.Size
            set a.Integer = a.BStream.Size
            set a.Float = a.BStream.Size
            set a.Double = a.BStream.Size
            set a.Date = +$H
            set a.Timestamp = $zdt($h,3)
            set a.Boolean = 1
            set sc = a.%Save()
        } else {
            set sc = $system.Status.Error("5001",filename _ " doesn't exist")
        }
    }
    Catch ex {
        Set sc=ex.AsStatus()
    }
    
    return sc
]]></Implementation>
</Method>

<Method name="BStreamPop">
<ClassMethod>1</ClassMethod>
<ReturnType>%Stream.GlobalBinary</ReturnType>
<Implementation><![CDATA[
    set file=##class(%Stream.FileBinary).%New()
    set filename=$system.Util.DataDirectory()_"docs/copyright.pdf"
	set sc=file.LinkToFile(filename)
    set stream=##class(%Stream.GlobalBinary).%New()
    do stream.CopyFrom(file)
    return stream
]]></Implementation>
</Method>

<Method name="CStreamPop">
<ClassMethod>1</ClassMethod>
<ReturnType>%Stream.GlobalCharacter</ReturnType>
<Implementation><![CDATA[
    set file=##class(%Stream.FileCharacter).%New()
    set filename=$system.Util.ManagerDirectory()_"messages.log"
	set sc=file.LinkToFile(filename)
    set stream=##class(%Stream.GlobalCharacter).%New()
    do stream.CopyFrom(file)
    return stream
]]></Implementation>
</Method>

<Method name="extractBinary">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%Integer,extension:%String="pdf",directory:%String="tmp"</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    set sc=$$$OK
    if ..%ExistsId(id) {
        set data=..%OpenId(id)
        set directory=##class(%File).NormalizeDirectory($system.Util.DataDirectory()_directory)
        do:'##class(%File).DirectoryExists(directory) ##class(%File).CreateDirectoryChain(directory)
        set filename=directory_id_"_BStream."_extension
        set file=##class(%Stream.FileBinary).%New()
        set sc= file.LinkToFile(filename)
        set sc=file.CopyFrom(data.BStream)
        set sc=file.%Save()
        write:sc filename," successfully extracted (",data.BStream.Size,")",file.Size,!
    } else {
        set sc=$SYSTEM.Status.Error(5001,id_" doesn't exist")
    }
    return sc
]]></Implementation>
</Method>

<Method name="extractCharacter">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%Integer,extension:%String="txt",directory:%String="tmp"</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    set sc=$$$OK
    if ..%ExistsId(id) {
        set data=..%OpenId(id)
        set directory=##class(%File).NormalizeDirectory($system.Util.DataDirectory()_directory)
        do:'##class(%File).DirectoryExists(directory) ##class(%File).CreateDirectoryChain(directory)
        set filename=directory_id_"_CStream."_extension
        set file=##class(%Stream.FileCharacter).%New()
        set sc= file.LinkToFile(filename)
        set sc=file.CopyFrom(data.CStream)
        set sc=file.%Save()
        write:sc filename," successfully extracted (",data.CStream.Size,")",file.Size,!
    } else {
        set sc=$SYSTEM.Status.Error(5001,id_" doesn't exist")
    }
    return sc
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^data.testD</DataLocation>
<DefaultData>testDefaultData</DefaultData>
<IdLocation>^data.testD</IdLocation>
<IndexLocation>^data.testI</IndexLocation>
<StreamLocation>^data.testS</StreamLocation>
<ExtentSize>2</ExtentSize>
<Data name="testDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>String</Value>
</Value>
<Value name="3">
<Value>BStream</Value>
</Value>
<Value name="4">
<Value>CStream</Value>
</Value>
<Value name="5">
<Value>Numeric</Value>
</Value>
<Value name="6">
<Value>Integer</Value>
</Value>
<Value name="7">
<Value>Float</Value>
</Value>
<Value name="8">
<Value>Double</Value>
</Value>
<Value name="9">
<Value>Date</Value>
</Value>
<Value name="10">
<Value>Timestamp</Value>
</Value>
<Value name="11">
<Value>Boolean</Value>
</Value>
<Value name="12">
<Value>extension</Value>
</Value>
<Value name="13">
<Value>created</Value>
</Value>
</Data>
<Property name="%%CLASSNAME">
<Selectivity>100.0000%</Selectivity>
<AverageFieldSize>2</AverageFieldSize>
</Property>
<Property name="%%ID">
<Selectivity>1</Selectivity>
<AverageFieldSize>3</AverageFieldSize>
</Property>
<Property name="BStream">
<Selectivity>50.0000%</Selectivity>
</Property>
<Property name="Boolean">
<Selectivity>100.0000%</Selectivity>
<AverageFieldSize>2</AverageFieldSize>
</Property>
<Property name="CStream">
<Selectivity>50.0000%</Selectivity>
</Property>
<Property name="Date">
<Selectivity>50.0000%</Selectivity>
<AverageFieldSize>4</AverageFieldSize>
</Property>
<Property name="Double">
<Selectivity>50.0000%</Selectivity>
<AverageFieldSize>10</AverageFieldSize>
</Property>
<Property name="Float">
<Selectivity>50.0000%</Selectivity>
<AverageFieldSize>4</AverageFieldSize>
</Property>
<Property name="Integer">
<Selectivity>50.0000%</Selectivity>
<AverageFieldSize>6</AverageFieldSize>
</Property>
<Property name="Numeric">
<Selectivity>50.0000%</Selectivity>
<AverageFieldSize>5.5</AverageFieldSize>
</Property>
<Property name="String">
<Selectivity>50.0000%</Selectivity>
<AverageFieldSize>3</AverageFieldSize>
</Property>
<Property name="Timestamp">
<Selectivity>50.0000%</Selectivity>
<AverageFieldSize>21</AverageFieldSize>
</Property>
<Property name="extension">
<Selectivity>100.0000%</Selectivity>
<AverageFieldSize>6</AverageFieldSize>
</Property>
<SQLMap name="BStreamIndex">
<BlockCount>-4</BlockCount>
</SQLMap>
<SQLMap name="BooleanIndex">
<BlockCount>-4</BlockCount>
</SQLMap>
<SQLMap name="CStreamIndex">
<BlockCount>-4</BlockCount>
</SQLMap>
<SQLMap name="DateIndex">
<BlockCount>-4</BlockCount>
</SQLMap>
<SQLMap name="DoubleIndex">
<BlockCount>-4</BlockCount>
</SQLMap>
<SQLMap name="FloatIndex">
<BlockCount>-4</BlockCount>
</SQLMap>
<SQLMap name="IDKEY">
<BlockCount>-4</BlockCount>
</SQLMap>
<SQLMap name="IntegerIndex">
<BlockCount>-4</BlockCount>
</SQLMap>
<SQLMap name="NumericIndex">
<BlockCount>-4</BlockCount>
</SQLMap>
<SQLMap name="StringIndex">
<BlockCount>-4</BlockCount>
</SQLMap>
<SQLMap name="TimestampIndex">
<BlockCount>-4</BlockCount>
</SQLMap>
</Storage>
</Class>
</Export>
